\chapter{Implemented Improvements to PlanetLab Server Manager}
\label{chapter:improve}
This Chapter will discuss improvements made to the PlanetLab application. The improvements are based on the analysis made in the Section~\ref{section:improvement}. The implementation details will be described and shown. The goal of the re-implementation is to make the \texttt{plmbng} tool simple to use, easier to contribute into by re-writing it fully into Python 3, using good coding practices, remove any post-installations steps and making small improvements. Improvements includes:
\begin{itemize}
	\item Removing result limitation by dynamically creating menu using Python \texttt{list}.
	\item Adding support to use application as library by logically separating each function.
	\item Increasing readability and improve orientation in the application by renaming menu components and using descriptive functions names.
	\item Eliminating pre and post installation steps by using automatic \texttt{pip} dependency installer.
	\item Improving credentials set up by adding internal text editor.
	\item Extending Windows support to several functions by detecting operating system and dynamically changing parameters.
	\item Few minor bug fixes and improvements.
\end{itemize}

\section{Re-design of Application}
\label{section:redesign}
This Section will describe the approach taken to improve the application. The issues of the application, described more in Section~\ref{section:improvement}, are that there are two different languages, functions are scattered and configuration management is not existing. During re-design, all these problems were taken into consideration and addressed. First problem, already well described, was solved by re-writing the application fully into Python 3 language. Second and third problem were resolved using re-design of the application folder structure and architecture. The overall architecture of re-designed application is shown in Figure~\ref{fig:archdiagram} and will be described in the next paragraph.\\

\begin{figure}[H]
	\centering
	\scalebox{0.8}{\includegraphics{obrazky/PlbmngArchitecture}}
	\caption{PlanetLab Server Manager architecture diagram.}
	\label{fig:archdiagram}
\end{figure}

Issue with scattered functions was solved using single file, the \texttt{engine.py}, for all the common internal functions and graphic functions and libraries for more complex functionality of the application. To make it easier to navigate inside the engine file, it was divided between graphic and internal logic sections. A question why not to split the graphical and internal logic might come to a mind. Currently, the engine module graphical and internal functions are calling each other as an reaction to certain states. Splitting them would mean importing each other in a circle which is not an ideal state. Having both sections in one file makes it one solid logical component, called the engine. However as mentioned, there are certain independent components that are split into their own files. In the Figure~\ref{fig:archdiagram}, these are described as \texttt{libs} and contains several utility functions that can be called independently and are imported as a library inside the \texttt{engine}. Currently, there are three of these utility modules. PlanetLab API interface, which provides functionality to update the list of servers, port scanner which allows to check port accessibility of remote host and lastly module that allows to render map of nodes using a dictionary of nodes as input. On of the challenges during re-design was a placeholder for all the information about nodes that application can later used. Previously, a text file was used to store this data. Issue with this is to implement a filter function for example, it would require to write a custom module for queries which is an unnecessary overhead as there are already solutions available to provide such module. One of these solution is relational database with SQL used as a query language. SQL is a structured query language designed to manipulate data in relational tables which are nothing more than set of related information~\cite{Beaulieu:2005:LS:1098720}. This fits perfectly application needs as it stores a set of nodes with their related status information. In the Figure~\ref{fig:archdiagram}, this is shown as an internal database module. Engine triggers update of status of available nodes whereas PlanetLab API interface library updates the list of nodes. Python provides a \texttt{SQLite3} library that allows creating a custom database stored on disk. This database file is placed inside the database folder in the application configuration management. Mentioned architecture decisions will allow application to be more easily salable and maintainable in the later development phases.\\


\section{Description of Improvements}
\label{section:implementapproach}
In this Section, the steps to achieve goals; which were described in the Chapter introduction; will be shown in detail in their own Subsections. For each Subsection the approach, specific steps, code examples and results will be illustrated. Since the new implementation uses \texttt{pythondialog} module, at the start of the tool an instance of the \texttt{Dialog} class is spawned and will be later described just as the \texttt{instance}.
\subsection{Removing Result Limitation}
The previous version of \texttt{plbmng} tool has been limited to 10 result when searching for a node. This issue was introduced due to difficulty of creating a menu based on dynamic results since author needed to always add a new argument to the overall command. This also can hit limitation of characters that can be passed in a Bash command line. In Python 3 this problem is non-existing since \texttt{pythondialog} module is creating menu functions based on list. During the search of the nodes, results are added to the list which is after completed search passed to the instance which renders the \zk{zkGUI} (\zkratkatext{zkGUI}). Example of this functionality is shown in Listing~\ref{lst:removingresultlimit}. Currently, the tool is returning all results found.
{\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Python, numbers=none, label={lst:removingresultlimit}, caption=Removing Result Limitation, frame=single, showstringspaces=false]
def searchNodesGui(prepared_choices):
	if not prepared_choices:
		d.msgbox("No results found.", width=0,height=0)
		return None
	while True:
		code, tag = d.menu("These are the results:",
							choices=prepared_choices,
							title="Search results")
\end{lstlisting}
\end{minipage}
\subsection{Writing the Application as Library}
For the application to be used in other scripts and reduced the need to re-write certain code parts it is desired to write application to be able to run as a library. During the re-implementation this was considered and application is available both as library and standalone script. This will be later used in the Subsection~\ref{section:improvement}. If the application is called as a standalone script, it will trigger part of the code that is shown in Listing~\ref{lst:pythoninit} and initialize a graphical interface for the user to use. If imported as a library, it allows the user to call any function defined in the script.

{\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Python, numbers=none, label={lst:descriptive}, caption=Example of Function Names, frame=single, showstringspaces=false, breaklines=true]
if __name__ == "__main__":
	initInterface()
	exit(0)
\end{lstlisting}
\end{minipage}

\subsection{Increasing Readability}
\label{subsection:readability}
Community is a powerful group that helps develop a tool and to add more functionality to it. To have community contribute to a tool, it should follow good practices and be easily readable. Previous version of the tool was using Bash script which was calling Python script and creating new Bash scripts on a disk which was merging using different pieces of code from pre-created \texttt{.dat} files in a \texttt{bin} folder. Finding a bug in this structure was difficult and non-intuitive. All these pieces of code were fully re-written into single Python script and logically divided into two sections. One section is for GUI functions and other is for logical functions. Each functions is very descriptive in its name as shown in Listing~\ref{lst:descriptive}.

{\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Python, numbers=none, label={lst:descriptive}, caption=Example of Function Names, frame=single, showstringspaces=false, breaklines=true]
def searchNodes(option,regex=None):
def initInterface():
def plotServersOnMap(mode):
def getPasswd():
def searchNodesGui(prepared_choices):
def printServerInfo(chosenOne):
def setCredentialsGui():
\end{lstlisting}
\end{minipage}

Each functions is trying to be as atomic as possible only having one purpose. This is helping to increase modularity of the application. Outside of this functions "categories" application is removing any \texttt{magic numbers} by defining constants at the beginning of the source code. This greatly helps to understand what is being passed as an argument and is shown in Listing~\ref{lst:constant} where it is descriptive what option is being passed as a search key to the \texttt{searchNodes} function. Also, the application has a block for \texttt{Initial settings} at the beginning for one single place where outside of functions definitions can be placed. Application is also honoring the conventions defined in \zk{zkPEP} (\zkratkatext{zkPEP}) 8 \cite{pythonpep}, like naming convention and space usage instead of tabs, as much as possible. In default, scripts like \texttt{pylint} uses snake case style naming convention however camel case that is actually described in the official pep 8 standards as a recommended descriptive naming style \cite{pythonpep}. All these small items described are increasing the overall readability of the application for others to quickly become familiarized with it. Currently, \texttt{engine.py} received score of 7.38  \texttt{pylint} with main complains being about missing doc strings and certain small warnings regarding wrong import and other small deviation from the PEP 8 standard.

{\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Python, numbers=none, label={lst:constant}, caption=Example of Constant Usage, frame=single, showstringspaces=false, breaklines=true]
code, tag = d.menu("Choose one of the following options:",
					choices=[("1", "Serach by DNS"),
				      		 ("2", "Search by IP"),
					    	   ("3", "Search by location")],
						       title="ACCESS SERVERS")
if code == d.OK:
	#Search by DNS
	if(tag == "1"):
		code, answer = d.inputbox("Search for:",title="Search")
		if code == d.OK:
			searchNodes(OPTION_DNS,answer)
		else:
			continue
\end{lstlisting}
\end{minipage}

As mentioned in the Section~\ref{section:improvement}, renaming certain parts of the tool can improve the readability. Since the tool is not data mining rather than server manager, the tool is internally renamed from \texttt{Data miner or PlanetLab} into \texttt{PlanetLab Server Manager}. Version is added next to the name for users to see which they are running immediately. Another example is renaming \texttt{Search nodes} to \texttt{Access servers} since primary function of this menu item is to access the servers while search is just supporting it. The re-designed application can be seen in Figure~\ref{fig:redesigned}.\\

\begin{figure}[H]
	\centering
	\scalebox{0.4}{\includegraphics{obrazky/plbmng_basic}}
	\caption{New re-designed menu with added name, version and various name changes.}
	\label{fig:redesigned}
\end{figure}

\subsection{Removal of Pre and Post Installation Steps}
Previous version of application required several pre and post installation steps. In the new version developed as part of this Diploma thesis, all these steps were removed. Pre-installation steps were eliminated by completely getting rid of dependencies on additional system packages. All the dependencies were moved into the PyPI package definition and are taken care off PyPI installer during installation of the tool. Post-installation steps were removed by adding the application into \texttt{bin} folder in the PyPI package. During installation, the PyPI installer automatically puts any scripts in the \texttt{bin} folder into a \texttt{\$PATH} folder making it accessible directly from command line without the need of accessing installation folder. The contents of the script located in \texttt{bin} folder can be seen in Listing~\ref{lst:plbmngbin}. The duplication of names seen in the Listing are created by having the \texttt{plbmng.py} script in the \texttt{plbmng} folder describing the library. This area is a good candidate for additional improvements that will be made later in the following Diploma thesis.

{\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Python, numbers=none, label={lst:plbmngbin}, caption=Source Code of Plbmng Executable Script, frame=single, showstringspaces=false, breaklines=true]
#!/usr/bin/env python3
import plbmng.plbmng
import sys

if len(sys.argv) > 1:
	if(str(sys.argv[1]) == 'crontab'):
		plbmng.plbmng.crontabScript()
		exit(0)
plbmng.plbmng.initInterface()
\end{lstlisting}
\end{minipage}}

\subsection{Credentials Improvement}
In the previous version of the tool the credentials were filled using \texttt{dialog} forms. When typing the credentials, nothing was shown except stars thus user was unaware where is the position of the cursor. Also saving of the credentials was not working properly resulting into the need to adjust the configuration file itself which required locating the file first by inspecting the source code. In the new version settings credential is improved by creating a virtual editor in the graphical interface itself, as shown in Figure~\ref{fig:credentials}, that allows the user transparently set the credentials. One of the disadvantage of this approach is plain text visible password in the editor as it is not hidden and user needs to be careful about setting the credentials in a safe environment. To the addition of this improvement, various credentials checks were added to the application. First run of the application will always trigger window advising user to fill credentials first. If a user chose to update a database without having credentials filled a warning message will pop-up warning the user about that fact. Also, when user wants to ssh to a server without having username and key filled he will have warning text near the ssh option. These improvements should prevent users forgetting about filling credentials and failing actions in the application.

\begin{figure}[H]
	\centering
	\scalebox{0.5}{\includegraphics{obrazky/credentials_figure}}
	\caption{New window for setting up credentials using internal text editor.}
	\label{fig:credentials}
\end{figure}

\subsection{Application Folder Structure Re-design}
With changes to the architecture of the application, folder management needs to be also adjusted accordingly. The root folder of the application contains two main parts, outside of necessary \texttt{PyPi} files. It is the \texttt{bin} folder with \texttt{plbmng} script itself and the \texttt{plbmng} folder which contains the whole application logic and graphical interface. This folder will be now described in detail. As shown in Section~\ref{section:redesign}, libraries are placed in the \texttt{lib} folder instead of \texttt{python\_scripts} previously. In past, the configuration files were stored in \texttt{bin} folder with some shell libraries. This is now re-named to \texttt{conf} folder and library functions are moved to the \texttt{lib} folder. There are information that needs to be stored persistently, like information about accessibility of nodes. For this purposes, there is a folder called \texttt{database} which contains file like \texttt{internal.db} which is already mentioned \texttt{SQLite3} database. With all these changes to the folder structure, the project should be now more transparent, clear and easier for other developers to join the project.

\subsection{Filtering Nodes Based on Accessibility}
One of the goals if this Diploma thesis was to add a functionality to filter nodes based on their accessibility. This subsection will describe how the functionality was designed and implemented. The overall idea was to add a way to filter current node based on their availability, have an option to change these settings, show these settings and have a way to update the data. In the following paragraph, all these items will be described more in detail.\\
As it was mentioned in Section~\ref{section:redesign}, the core of this functionality was to have a placeholder for the data about the nodes. This was achieved using the \texttt{SQLite3} Python library. To store the information, table \texttt{availability} was created and its structure can be seen in Table~\ref{table:availability}. First, \texttt{nkey} column is a primary key column that contains ID of the table row. Next is \texttt{shash} that contains unique hash of the node hostname. This hash is used to find already existing records so these are not duplicated but only updated. Hash is generated using md5 function and \texttt{hashlib} Python library. Next column is a \texttt{hostname} of the node for purposes of filtering and lastly there is the double \texttt{bssh} and \texttt{bping} which are Boolean flag displaying node accessibility. During inserting into the database, \texttt{nkey} is automatically incremented so only the other values needs to be specified. Before the filtering is explained, first the internal logic working with nodes needs to be explained. When an user asks to show nodes, the search function takes a dictionary of nodes as an input parameter. This simple logic is used for the filtering itself. In the function \texttt{getNodes()}, before the list of nodes is parsed, the current settings are loaded from the database from the \texttt{configuration} table which contains simply ID, name of the setting and Boolean if it is enabled or not. These settings are used to get all hostnames of the nodes that fits the current settings. For example if user wants to filter only ssh available nodes, the query will be \texttt{select * from availability where bssh='T'}. With the list of desired nodes the function will always return only nodes that fits user's filter criteria.  \\

\begin{table}[htb]
	\resizebox{\textwidth}{!}{\begin{tabular}{|l|l|l|l|l|}
			\hline
			\rowcolor[HTML]{EFEFEF} 
			nkey & shash                            & shostname                                & bssh & bping \\ \hline
			2    & fe27ca7d1707e86e1739b1819743dc79 & planetlab2.fri.uni-lj.si                 & F    & F     \\ \hline
			3    & 57da801bf4370f2a163a81bdf6bafa8c & ple01.fc.univie.ac.at                    & T    & F     \\ \hline
			4    & 3c956d5e295f17cb303773f83c84bf17 & aladdin.planetlab.extranet.uni-passau.de & T    & T     \\ \hline
		\end{tabular}
	}
\centering
\caption{Structure and examples of availability table for filtering functionality.}
\label{table:availability}
\end{table}

Applying filters is done using \texttt{Filtering options} in the \texttt{Access servers} menu. As shown in Figure~\ref{fig:filtering}, user can choose between ssh or ping available nodes. The selection is done using checkboxes. The choices are then shown in the  \texttt{Access servers} menu on the top as \textit{Active filters} line with the listing of the active options. \\

\begin{figure}[H]
	\centering
	\scalebox{0.6}{\includegraphics{obrazky/filtering}}
	\caption{Figure showing menu where user can select active filters.}
	\label{fig:filtering}
\end{figure}

\subsection{Updating Status Database}
Updating the status database, or to be precise updating table inside the database, can be triggered from the \texttt{Monitor servers} menu. This will start a progress bar that takes approximately two minutes after optimization. Before optimization, the procedure took around 40 minutes. This speed was reached using multi-processing. Once procedure to update database is triggered, fifty processes are spawned at a same time using Python \textit{multiprocessing} library. List of nodes is passed as an iterator to go over in a loop to the Pool object as shown in Listing~\ref{lst:multiprocess}. In addition, one lock is created to take over critical section of updating the shared status database and progress bar. Critical section can be defined as an area in a computer program where process operates on the shared variable by changes its value \cite{gebali2011algorithms}. Once a process reaches the critical section, it needs to acquire the lock to enter into it. Once a process has acquired the lock, it can start writing into the shared memory without any issue. As soon as it is done, the lock is released and another process can acquire it and start writing into the critical section. To be able to show correctly the progress, once a process finishes a task, it will lock the progress bar value, increase the progress variable with an increment that is derived from total number of nodes and then unlock the progress bar iterating to another node to gather information about it. The code of entering the critical section can be seen in  Listing~\ref{lst:lock}\\
 
{\noindent\begin{minipage}{\linewidth}
		\begin{lstlisting}[language=Python, numbers=none, label={lst:multiprocess}, caption=Creating a multi-processing object with fifty processes\, three shared variables and list of nodes as iterator., frame=single, showstringspaces=false, breaklines=true]
pool = Pool(50, initializer=multiProcessingInit,
			initargs=(lock,base,increment, ))
pool.map(updateAvailabilityDatabase, nodes)
		\end{lstlisting}
	\end{minipage} 

{\noindent\begin{minipage}{\linewidth}
		\begin{lstlisting}[language=Python, numbers=none, label={lst:lock}, caption=Entering a critical section and acquiring a lock., frame=single, showstringspaces=false, breaklines=true]
lock.acquire()
base.value = base.value = increment.value
updateProgressBarMultiProcessing(base.value)
lock.release()
		\end{lstlisting}
	\end{minipage} 

\subsection{Map Improvements}
In the previous version of the application, user could render all nodes in the node database on a map. It displayed markers which, upon clicking, showed hostname of the node. During implementation of filters, maps were also enhanced. Now, user can select between three maps to render; full map, map of nodes available over ssh and map of nodes that are ping-able. In addition, upon clicking, user can see all the stored information about the node as can be seen in Figure~\ref{fig:mapnodedetail}. The library for rendering the map was changed to use the same principle as search function. Instead of reading nodes from a file, it gets them passed as a parameter. While triggering the map module, nodes are loaded using \texttt{getNodes()} function that takes filtering into consideration in default. The filter in this case is only adjusted by the user's choice. Later, in Chapter~\ref{chapter:analysis} the information from map filters will be used to analyze \textit{PlanetLab Network} more in detail. For user, maps filters are good opportunity to see which server are actually available for project testing and possibly create an uniform list of candidate nodes that are spread all over the world. 

\begin{figure}[H]
	\centering
	\scalebox{0.65}{\includegraphics{obrazky/mapnodedetail}}
	\caption{Figure showing the detail of a node upon clicking on its marker.}
	\label{fig:mapnodedetail}
\end{figure}

\subsection{Minor Improvements}
In this Subsection, minor improvements done during the re-implementation are described. All these improvements were considered minor hence these are not having separate Subsection. More improvements to the tool will be done in the Diploma thesis following up on this Diploma thesis.
\paragraph{Clearing of the screen after cancel}
When signal was send to the application using \texttt{CTRL + C} key combination, the previous version of the application was not clearing the current terminal window and the GUI. To use the same terminal user was forced to clear the window manually. In the new version, when signal is send to the application, signal handler will catch it and clean after itself.
\paragraph{Recursion removal for return}
When returning from child window to a parent page, the previous version of application was recursively calling the GUI function. This is not following good coding habits as each recursive call means storing the previous function details into the system stack, unnecessarily filling it. In the new version, while cycle is used instead and returning from a function results into new iteration of the while cycle not storing anything onto the system stack. 
\paragraph{About is added to the menu}
About section is added to the menu displaying version, authors and the license.
\paragraph{Crontab mode created}
Application is possible to run with \texttt{crontab} argument which will trigger just monitoring of the nodes. This is in particular useful when setting the \texttt{crontab} since the call can be simply \texttt{plbmng crontab}. This mode can be used to setup a regular updates in background to the node database.
\paragraph{Last server access}
User has now ability to return to last accessed server it the \texttt{Access servers} menu. In default, this option will just print warning message that no node was accessed. However, as soon as user access first node, this node is stored into the database in form of dump of the node dictionary variable. If user wants to access the last accessed node, this dictionary is dumped back to an internal variable and used to show this node with all the information and options.
\paragraph{Menu with statistics}
Since status database already contains all the necessary information a simple functionality regarding accessibility of the stored nodes was added to the application as can be seen in Figure~\ref{fig:statmenu}. 

\begin{figure}[H]
	\centering
	\scalebox{0.6}{\includegraphics{obrazky/statmenu}}
	\caption{Newly added option to display current statistics about accessibility of stored nodes.}
	\label{fig:statmenu}
\end{figure}

\paragraph{Support of Multiple Platforms}
As was mentioned previously, Python is multi-platform language and brings possibility of porting the application to all kinds of operating systems. During the re-implementation of the application this was taken into considerations and new functions were written to be able to run on Linux, Mac and possibly later on even Windows. Example of this multi-platform implementation can be seen in Listing~\ref{lst:testping} showing function \texttt{testPing} supporting all mentioned operating systems. As both Linux and Mac are Unix based, the implementation for these operating system is fairly simple and only minor changes are usually in several parameters. Perfect example is \texttt{ping} function. On Mac, time-out parameter takes one integer in millisecond as input variable. However, on Linux, the time-out parameter takes the integer variable in seconds. These little differences needs to be kept in mind when implementing platform-based functions. For Windows however, the differences are even more complex and all the libraries used in \texttt{plbmng} have to have Windows support. This was never tested yet even though most of the functions were written with Windows in mind. Adding full Windows support is a good initiative for the future development of \texttt{plbmng}.

{\noindent\begin{minipage}{\linewidth}
		\begin{lstlisting}[language=Python, numbers=none, label={lst:testping}, caption=Multi-Platform Function testPing, frame=single, showstringspaces=false, breaklines=true]
def testPing(target, returnbool=False):
	pingPacketWaitTime = None
	if system().lower() == 'windows':
		pingParam = '-n'
	else:
		pingParam = '-c'
	#for Linux ping parameter takes seconds while MAC OS ping takes miliseconds
	if system().lower() == 'linux':
		pingPacketWaitTime = 1
	else:
		pingPacketWaitTime = 800
	command = ['ping', pingParam, '1', target, '-W', str(pingPacketWaitTime)]
	p = subprocess.Popen(command, stdout=subprocess.PIPE,
	stderr=subprocess.PIPE)
	# prepare the regular expression to get time
	if system().lower() == 'windows':
		avg = re.compile('Average = ([0-9]+)ms')
	else:
		avg = re.compile(
		'min/avg/max/[a-z]+ = [0-9.]+/([0-9.]+)/[0-9.]+/[0-9.]+')
		avgStr = avg.findall(str(p.communicate()[0]))
	if p.returncode != 0:
		if not returnbool:
			return "Not reachable via ICMP"
		return False
	else:
		p.kill()
		if not returnbool:
			return avgStr[0]+" ms"
		return True
		\end{lstlisting}
	\end{minipage}

\paragraph{updated pypi information..}
blablabla

\subsection{Minor Bug Fixes}
In this Subsection, minor bug fixes will be described which were not considered as enough improving to be included in separate Subsection. 
\paragraph{Removing headers from the searches}
During the search, previous version of the script has also included header of the file containing information about nodes resulting into false search results. Header is now skipped and these false results are removed.
\paragraph{Application crashes during return}
When returning from a child menu window to a parent page, the application tend to crash on \texttt{grep} tool not being able to find file. During re-implementation this bug was fixed and returning now fully works.

\section{Current Installation and Use of Application}
\label{section:currentapp}
In this Section, the post-improvements installation procedure is described and workflow diagram is shown in Figure~\ref{fig:workflowdiagram}. After implementing improvements, application has been updated in the PyPI repository and is available at \url{https://pypi.org/project/plbmng/} in version \texttt{0.3.5}. Application repository web page can be seen in Figure~\ref{fig:plbmngrepo} and is describing the tool purpose, its Python package dependencies, installation steps, basic usage and authors. Repository page gives ability to the user to see release history or download the source files of the project. It also show the maintainers of the projects and allows users to contact them. License under which the application is written can be found the repository page as well. As part of this Diploma thesis, the description was completely changed to reflect the current settings. It was improved to be more simple for the user by reducing amount of text on the page and keeping only necessary information.

\begin{figure}[H]
	\centering
	\scalebox{0.49}{\includegraphics{obrazky/plbmng_repo}}
	\caption{PlanetLab Server Manager web page in PyPI repository.}
	\label{fig:plbmngrepo}
\end{figure}

The installation steps are described in detail in the tool's repository page and consist of:

\begin{enumerate}
	\item Installing the application using \texttt{pip3 install plbmng} command.
	\item Starting the application using \texttt{plbmng} command.
	\item In first start it is required to set up credentials using the \texttt{Set credentials} option in menu.
\end{enumerate}

After this basic setup all the application functionality is available. It is recommended though, to update the list of nodes using \texttt{Get nodes} option in \texttt{Monitoring} menu. Installation steps are successfully reduced compared to the old version which consisted of:

\begin{enumerate}
	\item Installing system packages using \texttt{sudo dnf install -y dialog pssh fping} command.
	\item Installing the application using \texttt{pip install plbmng} command.
	\item Locating the application in a hidden folder of pip tool.
	\item Finding a configuration file and using an editor to update it.
	\item Running the application using absolute path.
\end{enumerate}

\paragraph{} To summarize, current application functionality workflow diagram can be seen in Figure~\ref{fig:workflowdiagram}. For clarity, the Figure is missing returning arrows however each node in the diagram is able to return to its parent. As seen in the Figure, first step is when menu is being initialized. From there user has option to either open \texttt{Access server menu}, \texttt{Monitor servers}, \texttt{Plot servers on map}, \texttt{Set credentials} or select \texttt{About}. \texttt{About} is a single window option that will show information about the software, its authors and license. \texttt{Set credentials} option will open an interactive editor where user can fill the credentials for PlanetLab network. Next option is \texttt{Plot servers on map} which offers user to choose which map elements should be rendered. After confirmation the map is generated and opened in the system default browser. \texttt{Monitor servers} option divides into three different options. First enables user to setup \texttt{crontab} to periodically scan for nodes, second option is for setting up monitoring elements and third triggers the scanning immediately. At last, \texttt{Access servers} allows users to access the nodes by searching for them either using DNS name, IP address or location. After the search key is inserted, the available results are shown. When specific node is chosen, information about the node are displayed and user has options to connect to the node using ssh, Midnight Commander or show the node on map.

\begin{figure}[H]
	\centering
	\scalebox{0.8}{\includegraphics{obrazky/BehavioralPlbmng}}
	\caption{PlanetLab Server Manager workflow diagram.}
	\label{fig:workflowdiagram}
\end{figure}

\chapter{PlanetLab Network Analysis Using Plbmng Tool}
\label{chapter:analysis}
blablabla
 
 \chapter{Example of Use Cases}
 \label{chapter:usecase}
 blablabla